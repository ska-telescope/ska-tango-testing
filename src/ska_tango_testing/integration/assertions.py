"""Basic custom event-based assertions for `TangoEventTracer`.

This module provides some example of basic custom
`assertpy <https://assertpy.github.io/index.html>`_ assertions
to be used with :py:class:`~ska_tango_testing.integration.TangoEventTracer`
instances. These assertions can be
used to verify properties about the events captured by the tracer.

Essentially they are query calls to the tracer, within
a timeout, to check if there are events which match an expected more or less
complex predicate.

Usage example:

.. code-block:: python

    from assertpy import assert_that, add_extension
    from ska_tango_testing.integration import (
        TangoEventTracer
    )
    from ska_tango_testing.integration.assertions (
        has_change_event_occurred,
        within_timeout,
    )

    def test_event_occurs_within_timeout(sut, tracer: TangoEventTracer):

        # subscribe to the events
        tracer.subscribe_event("devname", "attrname")
        tracer.subscribe_event("devname", "attr2")

        # ... do something that triggers the event

        # Check that a generic event has occurred
        assert_that(tracer).has_change_event_occurred(
            device_name="devname",
            attribute_name="attrname",
            attribute_value=5,
        )

        # Check that an attr change from "old_value" to "new_value"
        # has occurred or will occur within 5 seconds in any device.
        # Describe the eventual failure with an evocative message.
        assert_that(tracer).described_as(
            "An event from 'old_value' to 'new_value' for 'attr2' should have"
            " been occurred within 5 seconds in some device."
        ).within_timeout(5).has_change_event_occurred(
            # (if I don't care about the device name, ANY will match)
            attribute_name="attr2",
            attribute_value="new_value",
            previous_value="old_value",
        )

You can and you are encouraged to take those assertions as a starting point
to create more complex ones, as needed by your test cases. If you want to do
that we suggest to check `assertpy` documentation to understand
how to create custom assertions (https://assertpy.github.io/docs.html).


**NOTE**: Custom assertions of this module are already exported
to the `assertpy` context in :py:mod:`ska_tango_testing.integration`, so
if you are an end-user, if you import the module somewhere in your tests
you already have access to the assertions. Sometimes your IDE may not
recognize the custom assertions, but they are there.

**ANOTHER NOTE**: To make assertions about the events order
- i.e., assertion which include a verification with the shape
"event1 happens before event2", like when you use `previous_value` - we
are currently using the reception time
(:py:attr:`~ska_tango_testing.integration.event.ReceivedEvent.reception_time`)
as a way to compare events. it's important to remember that we are dealing with
a distributed system and the reception time may be misleading in some
cases (e.g., the reception time of the event may not be the same as the
time the event was generated by the device).

We noticed that in :py:class:`tango.EventData` there is a timestamp
which tells when the Tango server received the event. Maybe in the future
it would be better to use that instead of the reception time as a way to
compare events (if it comes from a centralized server and not from the
device itself, because it is important to remember that in distributed
systems the devices' clocks may not be perfectly synchronized).
"""  # pylint: disable=line-too-long

from typing import Any, Callable

# pylint: disable=unused-import
import tango

from .assertions_utils import ChainedAssertionsTimeout
from .event import ReceivedEvent
from .query import NStateChangesQuery
from .tracer import TangoEventTracer


def _get_tracer(assertpy_context: Any) -> TangoEventTracer:
    """Get the `TangoEventTracer` instance from the `assertpy` context.

    Helper method to get the
    :py:class:`~ska_tango_testing.integration.TangoEventTracer`
    instance from the `assertpy` context which is stored in the 'val'.
    It fails if the instance is not found.

    :param assertpy_context: The `assertpy` context object.

    :return: The `TangoEventTracer` instance.

    :raises ValueError: If the
        :py:class:`~ska_tango_testing.integration.TangoEventTracer`
        instance is not found (i.e., the assertion is not called with
        a tracer instance).
    """
    if not hasattr(assertpy_context, "val") or not isinstance(
        assertpy_context.val, TangoEventTracer
    ):
        raise ValueError(
            "The 'TangoEventTracer' instance must be stored in the 'val' "
            "attribute of the assertpy context. Try using the 'assert_that' "
            "method with the 'TangoEventTracer' instance as argument.\n"
            "Example: assert_that(tracer).has_change_event_occurred(...)"
        )
    return assertpy_context.val


def within_timeout(assertpy_context: Any, timeout: int | float) -> Any:
    """Add a timeout for the next chain of tracer assertions.

    :py:class:`~ska_tango_testing.integration.TangoEventTracer`
    allows to query events within a timeout. In other words, you can
    make assertions about events that will occur in the future within
    a certain time frame and "await" for them (if they didn't occur yet).
    This method when called inside an assertion context permits
    you to set a timeout for the next chain of assertions.

    **IMPORTANT NOTE**: The timeout, like one may intuitively expect, is
    shared between all the chained assertions. This means that if you set
    a timeout of 10 seconds and you have 3 chained assertions, the total
    time to wait for all the events to occur is 10 seconds, not 30 seconds.
    Concretely, each assertion will consume some time from the timeout, until
    it reaches zero.

    Usage example:

    .. code-block:: python

        # (given a subscribed tracer)

        # non-blocking long operation that triggers an event at the end
        sut.long_operation_that_triggers_an_event()

        # Check that the operation is done within 30 seconds
        assert_that(tracer).within_timeout(30).has_change_event_occurred(
            attribute_name="operation_state",
            attribute_value="DONE",
        )

    Alteratively, when you want to verify a set of events occurring
    within a certain shared timeout:

    .. code-block:: python

        # Check that the 3 events occur within 30 seconds
        assert_that(tracer).within_timeout(30).has_change_event_occurred(
            attribute_name="operation_state",
            attribute_value="INITIAL_STATE",
        ).has_change_event_occurred(
            attribute_name="operation_state",
            attribute_value="PROCESSING",
        ).has_change_event_occurred(
            attribute_name="operation_state",
            attribute_value="DONE",
        )

        # IMPORTANT NOTE: this will NOT verify that the events occur in the
        # given order, just that they occur within the same timeout!

    **NOTE**: this assertion always passes, its only purpose is to
    set the timeout for the following assertions.

    **NOTE**: Using a (small) timeout is a good practice even in not so long
    operations, because it makes the test more robust and less prone to
    flakiness and false positives.

    :param assertpy_context: The `assertpy` context object
        (It is passed automatically)
    :param timeout: The time in seconds to wait for the event to occur.

    :return: The decorated assertion context, with a
        :py:class:`~ska_tango_testing.integration.assertions_utils.ChainedAssertionsTimeout`
        instance stored in the ``event_timeout`` attribute.

    :raises ValueError: If the
        :py:class:`~ska_tango_testing.integration.TangoEventTracer`
        instance is not found (i.e., the method is called outside
        an ``assert_that(tracer)`` context).
    """  # pylint: disable=line-too-long # noqa: E501 DAR402
    # verify the tracer is stored in the assertpy context or raise an error
    _get_tracer(assertpy_context)

    # add the timeout to the assertion
    assertpy_context.event_timeout = ChainedAssertionsTimeout(timeout)

    return assertpy_context


def has_change_event_occurred(
    assertpy_context: Any,
    device_name: "str | tango.DeviceProxy | None" = None,
    attribute_name: str | None = None,
    attribute_value: Any | None = None,
    previous_value: Any | None = None,
    custom_matcher: Callable[[ReceivedEvent], bool] | None = None,
    min_n_events: int = 1,
) -> Any:
    """Verify that an event matching a given predicate occurs.

    Custom `assertpy` assertion to verify that a certain event occurs,
    eventually within a specified timeout. When it fails,
    it provides a detailed error message with the events captured by the
    tracer, the passed parameters and some timing information.

    If you wish, you can also specify a minimum number of events
    that must match the predicate (through the ``min_n_events`` parameter),
    to verify that **at least** a certain number of events occurred [within the
    timeout]. By default, it checks that  **at least one event** matches the
    predicate.

    To describe the event to match, you can pass the following parameters
    (all optional):

    - the name of the device you are interested in
    - the name of the attribute you are interested in
    - the current value of the attribute (the value that the attribute
      has when the event is captured)
    - the previous value of the attribute (the value that the attribute
      had before the event is captured - pretty useful to catch state
      transitions from a value to another)
    - an arbitrary predicate over the event (to deal tricky cases where
      a simple value comparison is not enough or is not possible)

    Usage example:

    .. code-block:: python

        # (given a subscribed tracer)

        # Check that an attr change from "old_value" to "new_value"
        assert_that(tracer).has_change_event_occurred(
            device_name="devname",
            attribute_name="attrname",
            attribute_value="new_value",
            previous_value="old_value",
        )

        # Just check that there is an event with the value "new_value"
        # (from any device and with any previous value)
        assert_that(tracer).has_change_event_occurred(
            attribute_name="attrname",
            attribute_value="new_value",
        )

        # Add an arbitrary condition
        assert_that(tracer).has_change_event_occurred(
            attribute_name="other_attrname",
            custom_matcher=lambda e: e.attribute_value > 5,
        )

        # Perform the same check, but look for AT LEAST 3 matching events.
        assert_that(tracer).has_change_event_occurred(
            attribute_name="attrname",
            attribute_value="new_value",
            min_n_events=3,
        )

    :param assertpy_context: The `assertpy` context object
        (It is passed automatically)
    :param device_name: The device name to match. If not provided, it will
        match any device name.
    :param attribute_name: The attribute name to match. If not provided,
        it will match any attribute name.
    :param attribute_value: The current value to match. If not provided,
        it will match any current value.
    :param previous_value: The previous value to match. If not provided,
        it will match any previous value.
    :param custom_matcher: An arbitrary predicate over the event. It is
        essentially a function or a lambda that takes an event and returns
        ``True`` if it satisfies your condition. NOTE: it is put in ``and``
        with the other specified parameters.
    :param min_n_events: The minimum number of events to match for the
        assertion to pass; verifies that at least n events have occurred.
        If not provided, it defaults to 1. If used without a timeout, the
        assertion will only check events received up to the time of calling.
        If specified, it must be a positive integer >= 1.

    :return: The `assertpy` context object.

    :raises ValueError: If the
        :py:class:`~ska_tango_testing.integration.TangoEventTracer`
        instance is not found (i.e., the method is called outside
        an ``assert_that(tracer)`` context).
    """  # noqa: DAR402
    # pylint: disable=too-many-arguments

    # check assertpy_context has a tracer object
    tracer = _get_tracer(assertpy_context)

    # get the remaining timeout if it exists
    timeout: ChainedAssertionsTimeout | float = getattr(
        assertpy_context, "event_timeout", 0.0
    )

    # Create and evaluate the query with a tracer
    query = NStateChangesQuery(
        device_name=device_name,
        attribute_name=attribute_name,
        attribute_value=attribute_value,
        previous_value=previous_value,
        custom_matcher=custom_matcher,
        target_n_events=min_n_events,
        timeout=timeout,
    )
    tracer.evaluate_query(query)

    # if not enough events are found, raise an error
    if not query.succeeded():
        msg = (
            f"Expected to find {min_n_events} event(s) "
            + "matching the predicate"
        )
        if isinstance(timeout, ChainedAssertionsTimeout):
            msg += f" within {timeout.initial_timeout} seconds"
        else:
            msg += " in already existing events"
        msg += f", but only {len(query.matching_events)} found.\n\n"

        events_list = "\n".join([str(event) for event in tracer.events])
        msg += f"Events captured by TANGO_TRACER:\n{events_list}"

        msg += "\n\nTANGO_TRACER Query details:\n"
        msg += query.describe()

        return assertpy_context.error(msg)

    return assertpy_context


def hasnt_change_event_occurred(
    assertpy_context: Any,
    device_name: "str | tango.DeviceProxy | None" = None,
    attribute_name: str | None = None,
    attribute_value: Any | None = None,
    previous_value: Any | None = None,
    custom_matcher: Callable[[ReceivedEvent], bool] | None = None,
    max_n_events: int = 1,
) -> Any:
    """Verify that an event matching a given predicate does not occur.

    It is the opposite of :py:func:`has_change_event_occurred`. It verifies
    that no event(s) matching the given conditions occurs, eventually within a
    specified timeout. When it fails, it provides a detailed
    error message with the events captured by the tracer,
    the passed parameters and some timing information.

    If you wish, you can also specify a maximum number of events
    that must match the predicate (through the ``max_n_events`` parameter),
    to verify that **no more than** a certain number of events occurred
    [within the timeout]. By default, it checks that
    **no more than one event** matches the predicate.

    The parameters are the same as :py:func:`has_change_event_occurred`.

    Usage example:

    .. code-block:: python

        # (given a subscribed tracer)

        # Check that none of the captured events has the value "ERROR"
        assert_that(tracer).hasnt_change_event_occurred(
            attribute_value="ERROR",
        )


    :param assertpy_context: The assertpy context object
        (It is passed automatically)
    :param device_name: The device name to match. If not provided, it will
        match any device name.
    :param attribute_name: The attribute name to match. If not provided,
        it will match any attribute name.
    :param attribute_value: The current value to match. If not provided,
        it will match any current value.
    :param previous_value: The previous value to match. If not provided,
        it will match any previous value.
    :param custom_matcher: An arbitrary predicate over the event. It is
        essentially a function or a lambda that takes an event and returns
        ``True`` if it satisfies your condition. NOTE: it is put in ``and``
        with the other specified parameters.
    :param max_n_events: The maximum number of events to match before the
        assertion fails; verifies that no more than n-1 events have occurred.
        If not provided, it defaults to 1. If used without a timeout, the
        assertion will only check events received up to the time of calling.
        If specified, it must be a positive integer >= 1.

    :return: The assertpy context object.

    :raises ValueError: If the
        :py:class:`~ska_tango_testing.integration.TangoEventTracer`
        instance is not found (i.e., the method is called outside
        an ``assert_that(tracer)`` context).
    """  # noqa: DAR402
    # pylint: disable=too-many-arguments

    # check assertpy_context has a tracer object
    tracer = _get_tracer(assertpy_context)

    # get the remaining timeout if it exists
    timeout: ChainedAssertionsTimeout | float = getattr(
        assertpy_context, "event_timeout", 0.0
    )

    # Create and evaluate the query
    query = NStateChangesQuery(
        device_name=device_name,
        attribute_name=attribute_name,
        attribute_value=attribute_value,
        previous_value=previous_value,
        custom_matcher=custom_matcher,
        target_n_events=max_n_events,
        timeout=timeout,
    )
    tracer.evaluate_query(query)

    # if enough events are found, raise an error
    if query.succeeded():
        msg = (
            f"Expected to NOT find {max_n_events} event(s) "
            + "matching the predicate"
        )
        if isinstance(timeout, ChainedAssertionsTimeout):
            msg += f" within {timeout.initial_timeout} seconds"
        else:
            msg += " in already existing events"
        msg += f", but {len(query.matching_events)} were found."

        event_list = "\n".join([str(event) for event in tracer.events])
        msg += f"Events captured by TANGO_TRACER:\n{event_list}"

        msg += "\n\nTANGO_TRACER Query details:\n"
        msg += query.describe()

        msg += "NOTE: the query looks for N events, but in this case, "
        msg += "you are expecting to find none."

        assertpy_context.error(msg)

    return assertpy_context
